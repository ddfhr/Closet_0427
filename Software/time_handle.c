#include "time_handle.h"

// 定义一个静态指针，用于存储定时器的链表头部
static struct Timer *head_handle = NULL;
// 定义一个静态变量，用于记录时间判断的数据
static unsigned int _timer_ticks = 0;

/*
**********************************************************************************************************
定时器回调函数程序
**********************************************************************************************************
*/
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
    // 判断是否为定时器4
    if (htim->Instance == htim4.Instance)
    {
        // 增加时间判断数据的计数
        _timer_ticks++;
    }
}
/*
**********************************************************************************************************
软定时使用定时器初始化
**********************************************************************************************************
*/
void timer_peripheral_init(void)
{
    // 启动定时器4的中断模式
    HAL_TIM_Base_Start_IT(&htim4);
}
/*
**********************************************************************************************************
创建一个结构体储存定时器的结构体,并赋值
**********************************************************************************************************
*/
void timer_init(struct Timer *handle, void (*timeout_cb)(), unsigned int timeout, unsigned int repeat)
{
    // 设置回调函数指针
    handle->timeout_cb = timeout_cb;
    // 设置定时器的到期时间（当前时间加上超时时间）
    handle->timeout = _timer_ticks + timeout;
    // 将下一个定时器设置为空
    handle->next = NULL;

    // 如果设置了重复触发，则设置间隔时间为重复时间，否则为0
    if (repeat != 0)
    {
        handle->repeat = timeout;
    }
    else
    {
        handle->repeat = 0;
    }
}

/*
**********************************************************************************************************
将新建的结构体添加进链表中  新加入的表指针地址
**********************************************************************************************************
*/
int timer_start(struct Timer *handle)
{
    // 初始化一个指针，指向链表的头部
    struct Timer *target = head_handle;

    // 遍历链表，检查是否已存在相同的定时器
    while (target)
    {
        // 如果找到与要添加的定时器相同的定时器，则返回-1表示添加失败
        if (target == handle)
        {
            return -1; // 已经存在。
        }
        // 如果当前元素不是最后一个元素，则移动到下一个元素继续比较
        target = target->next;
    }

    // 将新加入的定时器的下一个地址设置为头部的地址
    handle->next = head_handle;
    // 将新加入的定时器的地址存储到头部指针变量中
    head_handle = handle;
    // 添加成功，返回0表示执行成功
    return 0;
}
/*
**********************************************************************************************************
将新建的结构体添加进链表中  新加入的表指针地址
**********************************************************************************************************
*/
void timer_stop(struct Timer *handle)
{
    // 定义一个二级指针，用于遍历链表并修改链表结构
    struct Timer **curr = &head_handle;

    // 从链表头部开始遍历，直到链表结束
    while (*curr)
    {
        // 定义一个临时变量，用于存储当前节点的指针
        struct Timer *entry = *curr;

        // 判断当前节点是否是要停止的节点
        if (entry == handle)
        {
            // 将当前节点的下一个节点赋值给当前节点，相当于将当前节点从链表中移除
            *curr = entry->next;
        }
        else
        {
            // 如果当前节点不是要停止的节点，则移动到下一个节点
            curr = &entry->next;
        }
    }
}
/*
**********************************************************************************************************
main timer_loop();放在while(1)内
**********************************************************************************************************
*/
void timer_loop()
{
    // 定义一个临时变量，用于遍历链表
    struct Timer *target;

    // 遍历整个链表
    for (target = head_handle; target; target = target->next)
    {
        // 判断当前元素的采集周期是否大于计时变量
        if ((int)target->timeout - (int)_timer_ticks <= 0)
        { // 为了防止溢出
            // 判断是否开启了循环
            if (target->repeat == 0)
            {
                // 将未开启循环的元素剔除链表
                timer_stop(target);
            }
            else
            {
                // 初始化时已经将间隔时间赋值给repeat，timeout用来记录的到期时间
                // 下次到期时间 = 当前时间 + 间隔时间
                target->timeout = _timer_ticks + target->repeat;
            }
            // 执行当前元素的回调函数
            target->timeout_cb();
        }
    }
}
